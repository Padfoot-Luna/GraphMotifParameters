"""
Routines for generating cube-like graphs and
finding and verifying their subspace-related homomorphisms.
"""

import logging as log
from sage.modules.free_module import VectorSpace
from sage.rings.finite_rings.constructor import GF
from sage.misc.misc import powerset
from sage.graphs.graph import Graph

from homomorphisms import extend_hom, is_hom

def CayleyGraph(vspace, gens, directed=False):
  """
  Generate a Cayley Graph over given vector space with edges
  generated by given generators. The graph is optionally directed.
  Try e.g. CayleyGraph(VectorSpace(GF(2), 3), [(1,0,0), (0,1,0), (0,0,1)])
  """
  G = Graph()
  for v in vspace:
    G.add_vertex(tuple(v))
    for g in gens:
      g2 = vspace(g)
      G.add_edge(tuple(v), tuple(v + g2))
  return G


def nonisomorphic_cubes_Z2(n, avoid_complete=False):
  """
  Returns a generator for all n-dimensional Cube-like graphs
  (Cayley graphs over Z_2^n) with their generators.
  With avoid_complete=True avoids the complete graph.
  Iterates over tuples (generatorSet, G).
  """
  vs = VectorSpace(GF(2), n)
  basegens = vs.gens()
  optgens = [v for v in vs if sum(map(int,v)) >= 2]
  total = 2**len(optgens)
  seen_graphs = set()
  c = 0
  for g in powerset(optgens):
    c += 1
    gens = tuple(list(basegens) + g)
    if c % (total / 100 + 1) == 0:
      log.debug("Generating (%d of %d)" % (c, total))
    if avoid_complete:
      if len(g) >= len(optgens):
        continue
    G = CayleyGraph(vs, gens)

    canon = tuple(Graph(G).canonical_label().edges())
    if canon in seen_graphs:
      continue
    log.debug("Unique graph (%d of %d) gens=%s" % (c, total, gens))
    seen_graphs.add(canon)

    yield (gens, G)


def squash_cube(G, c):
  """
  Assuming G is a cube-like _undirected_ graph (Cayley over Z_2^n),
  given a vector c from Z_2^n, finds a homomorphism unifying
  vectors differing by c. One of the vertives (v, v+c) still must
  be chosen as the target for the homomorphism in each such pair.

  Returns a hom map to a subgraph or None if none such exists.
  """
  n = len(c)
  vs = VectorSpace(GF(2), n)
  c = vs(c)

  pairs = {}   # vertex -> pair
  for v in G.vertices():
    w = tuple(vs(v) + c)
    if G.has_edge(v, w):
      return False # contracting an edge!
    if w in pairs or v in pairs: continue
    pairs[v] = (v, w)
    pairs[w] = (v, w)
  chosen = {}  # pair -> 0 or 1 (first or second in the pair)
  undecided = set(pairs.values()) # undecided pairs

  def extend(pair, sel):
    """Extend `chosen[]` by setting pair to sel (0 or 1).
    Recursively chooses for pairs forced by this coloring.
    Returns False on inconsistency, True if all the forcing
    succeeded."""
    if pair in chosen:
      if chosen[pair] != sel:
        return False
      return True
    chosen[pair] = sel
    if pair in undecided:
      undecided.remove(pair)
    v = pair[sel]
    w = pair[1 - sel]

    for n in G.neighbors(v):
      np = pairs[n]
      ni = np.index(n)
      if G.has_edge(n, w):
        continue
      if not extend(np, ni):
        return False
    return True

  while undecided:
    p = undecided.pop()
    if not extend(p, 0):
      return None
  # create the hom-map
  hom = {}
  for p, sel in chosen.items():
    hom[p[0]] = p[sel]
    hom[p[1]] = p[sel]
  return hom


def hom_is_by_subspace(G, vs, h, require_isomorphic=True):
  """
  Check whether for a given homomorphism `h`, there is a subspace `span` of `vs` such that
  `h` unifies exactly vertices differing by element of `span` (alternatively: `h` factorizes
  the vertices of `G` by a subspace of `vs`).

  If you specify require_isomorphic=False, each of the unified vertex group is checked to be an
  affine subspace, but these subspaces are not required to be isomorphic.

  Returns True/False.
  """
  span_com = None
  for im in h.values():
    src = [vs(v) for v in G if h[v] == im]
    src0 = [i - src[0] for i in src]
    span = vs.span(src0)
    if len(src0) < 2**span.dimension():
      # log.debug("Dim of span too large %d for %s from %s", span.dimension(), src0, src)
      return False
    if require_isomorphic:
      if span_com is None:
        span_com = span
      if span_com != span:
        # log.debug("Subspaces not isomorphic: %s vs %s", span, span_com)
        return False
  return True


## Module unit testing


def raises(f):
  "Internal helper for testing."
  try:
    f()
  except:
    return True
  return False


def test():
  "Run unit tests for the module."
  log.getLogger().setLevel(log.DEBUG)

  from sage.graphs.graph_generators import graphs
  K2 = graphs.CompleteGraph(2)
  K4 = graphs.CompleteGraph(4)
  Z2_3 = VectorSpace(GF(2), 3)
  Z2_2 = VectorSpace(GF(2), 2)

  # nonisomorphic_cubes_Z2
  assert len(list(nonisomorphic_cubes_Z2(1))) == 1
  assert len(list(nonisomorphic_cubes_Z2(2))) == 2
  assert len(list(nonisomorphic_cubes_Z2(3))) == 6

  # CayleyGraph
  K4b = CayleyGraph(Z2_2, [(1,0), (0,1), (1,1)])
  assert K4.is_isomorphic(K4b)

  # squash_cube
  Ge = CayleyGraph(Z2_2, [(1,0), (0,1)])
  Smap = squash_cube(Ge, (1,1))
  K2e = Ge.subgraph(Smap.values())
  assert K2.is_isomorphic(K2e)
  assert is_hom(Ge, K2e, Smap)

  # hom_is_by_subspace
  Gg = CayleyGraph(Z2_3, [(1,0,0), (0,1,0)])
  Hg = CayleyGraph(Z2_2, [(1,0), (0,1), (1,1)])
  homg = {(0,0,0):(0,0), (1,0,0):(1,0), (0,1,0):(0,1), (1,1,0):(1,1),
          (0,0,1):(0,0), (1,0,1):(1,0), (0,1,1):(1,1), (1,1,1):(0,1)}
  assert is_hom(Gg, Hg, homg)
  assert hom_is_by_subspace(Gg, Z2_3, homg, require_isomorphic=False)
  assert not hom_is_by_subspace(Gg, Z2_3, homg, require_isomorphic=True)
  for h in extend_hom(Gg, K2, limit=10):
    assert hom_is_by_subspace(Gg, Z2_3, h, require_isomorphic=True)

  log.info("All tests passed.")

